# RabbitMQ

iZ2vc1kz9v8wez8o9nm5zpZ

用高效可靠的消息传递机制来进行与平台无关的数据交流，并基于数据通信来进行分布式系统的集成。通过提供消息传递和消息队列模型，可以在分布式环境下扩展进程的通信；-------------  MQ是用来解决通信问题的，**帮助我们存储和转发消息**；

![image-20210425183455973](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20210425183455973.png)

​						同步																异步

<img src="C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20210425183728380.png" alt="image-20210425183728380" style="zoom:50%;" /><img src="C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20210425183728380.png" alt="image-20210425183728380" style="zoom:50%;" />

应用情况：

```
stockService.updateInventory ();
payService.refund();
noticeService.notice()
```

这个过程是串行执行的，并且这三个动作本质上没有严格的先后顺序，也没有直接的依赖关系，谁先执行并不影响后续动作；这时如果我们想提高效率，让这三个动作并行执行，有什么思路？

多线程执行：多线程可以完成要求，但是需要在每个任务执行的地方引入线程，然后也会带来线程/线程池的管理；

引入MQ实现三个系统的解耦合,解耦合之后的关系如图：

![image-20210426145605239](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20210426145605239.png)

左边的订单系统只需要把消息发生到消息队列上；右边的业务只需要自己创建队列，然后监听其中的消息；



## 使用MQ的好处：

- 高可靠
- 灵活的路由
- 支持多客户端
- 集群与扩展性
- 高可用队列
- 权限管理
- 加减系统
- 与Spring集成 Spring AMQP

MQ的特点：

- 是一个独立运行的服务。生产者发送消息，消费者接收消费，需要先跟
  服务器建立连接。
- 采用队列作为数据结构，具有先进先出的特点；
- 具有发布订阅的模型，消费者可以获取自己需要的信息；
- 系统解耦合

- 流量削峰-----见问题②





**问题②**：

在一个电商系统中，流量有时会因为一些活动而剧增，如果公司的服务器承受不了这么大流量，现在你有什么解决办法？

- 增加物理设备：当流量高峰过去之后，就会有很大的资源浪费。
- 限流： 限流虽然可以保护到服务器，但是这样会减少了流量访问即订单的减少

**应该使用MQ：**

这样，我们就可以先把所有的流量承接下来，转换成 MQ 消息发送到消息队列服务
器上，业务层就可以根据自己的消费速率去处理这些消息，处理之后再返回结果。就像
我们在火车站排队一样，大家只能一个一个买票，不会因为人多就导致售票员忙不过来。
如果要处理快一点，大不了多开几个窗口（增加几个消费者）。



**带来的问题**：

由于MQ的存在，降低了系统的可用性，同时增加了复杂性，还可能存在数据不一致问题。

必须要考虑消息丢失和消息重复消费的问题；



**java中有许多队列，为什么不用他们呢？**

Queue不能跨进程，不能用于分布式，并且没有持久化机制；



## MQ的工作模型

![image-20210426151012836](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20210426151012836.png)

1. Broker / 中介：默认端口是 5672，负责存储`转发消息；
2. Connection： 连接是一个TCP的长连接
3. Channel : 类似于线程池的作用，减少每次消息都创建和释放连接开销
4. Queue ：消费者获取消息有两种模式，一种是 Push 模式，只要生产者发到服务器，就马上推送给消费者。另一种是 Pull 模式，消息存放在服务端，只有消费者主动获取才能拿到消息。
5. Exchange ：RabbitMQ中不会出现：消息直接发送到队列的情况（在其他一些 MQ 里面，比如ActiveMQ 和 Kafka，我们的消息都是发送到队列上的）交换机是一个绑定列表，用来查找匹配的绑定关系。队列使用绑定键（Binding Key）跟交换机建立绑定关系。**生产者发送的消息需要携带路由键（Routing Key），交换机收到消息时会根据它保存的绑定列表**，决定将消息路由到哪些与它绑定的队列上。
6. Vhost ：虚拟主机  可以实现资源的隔离和权限的控制



**消息队列的路由方式**：

- 直连方式
- 主题方式
- 广播方式



maven依赖：

```
<dependency>
    <groupId>com.rabbitmq</groupId>
    <artifactId>amqp-client</artifactId>
    <version>5.6.0</version>
</dependency>
```



## 死信队列



什么是死信交换机和死信队列？

​	

消息时候变成死信？----消息被消费者拒绝；消息过期；队列达到最大长度后，最先入队的消息会被发送到DLX;

死信队列如何使用？

可以通过x-dead-letter-exchange 设置为死信交换机；



**延迟队列**

实际应用中有一些需要用到延时发送消息的情景，

- 未支付的订单在15分钟后自动取消；
- 家里的智能热水器，需要在30分钟后启动；

RabbitMQ中本身没有延迟队列，大概有三种实现方案：

1. 先存储到数据库，用定时任务扫描
2.  利用 RabbitMQ 的死信队列（Dead Letter Queue）实现
3.  利用 rabbitmq-delayed-message-exchange 插件



一个重要的配置：

**prefetch cont**：消费端限流；消费端最大没被确认消息；



``11111111111111111111  

## Spring AMQP

AMQP: Advanced Message Queuing Protocol（高级消息队列协议）;是应用层协议的一个开发标准，为面向消息的中间件设计；

Spring集成AMQP时，它做了什么？

Spring AMQP包括什么？





消息冗余

分布式事务  



遇到的问题：

连接时slf4j出错，没有导入依赖

```
<dependency>
            <groupId>ch.qos.logback</groupId>
            <artifactId>logback-classic</artifactId>
            <version>1.3.0-alpha5</version>
        </dependency>
        <!-- https://mvnrepository.com/artifact/org.slf4j/slf4j-api -->
        <dependency>
            <groupId>org.slf4j</groupId>
            <artifactId>slf4j-api</artifactId>
            <version>2.0.0-alpha1</version>


```



## 事务问题

**一、两阶段提交（2PC）需要数据库产商的支持，java组件有atomikos等。**

​	 同步阻塞 所有事务参与者在等待其它参与者响应的时候都处于同步阻塞状态，无法进行其它操作。协调者在 2PC 中起到非常大的作用，发生故障将会造成很大影响。特别是在阶段二发生故障，所有参与者会一直等待状态，无法完成其它操作。

**二、补偿事务（TCC） 严选，阿里，蚂蚁金服。**

​	TCC 其实就是采用的补偿机制，其核心思想是：针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作。它分为三个阶段：

- Try 阶段主要是对业务系统做检测及资源预留
- Confirm 阶段主要是对业务系统做确认提交，Try阶段执行成功并开始执行 Confirm阶段时，默认 - - - Confirm阶段是不会出错的。即：只要Try成功，Confirm一定成功。
- Cancel 阶段主要是在业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放。



### 三、本地消息表（异步确保）比如：支付宝、微信支付主动查询支付状态，对账单的形式

优点： 一种非常经典的实现，避免了分布式事务，实现了最终一致性。
		缺点： 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。



### 四、MQ 事务消息 异步场景，通用性较强，拓展性较高。

优点： 实现了最终一致性，不需要依赖本地数据库事务。
		缺点： 实现难度大，主流MQ不支持，RocketMQ事务消息部分代码也未开源。

![img](https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/03/06/kuangstudy1b6c35f1-5c36-44b4-8f3b-a76f1fd94374.png)

冗余表的使用：下面是消息本来的样子，然后会增加对应的冗余信息，即加上一个字段消息状态：初始status=0，当交换机收到信息后返回确认信息。客户端就更新冗余表，让status=1；同时使用定时任务，定时重发status=0的消息；

补充：消费者在消费过程中出现异常：可能会出现死循环，因为定时任务会不断重试；导致磁盘被占满；

- 解决办法三种办法：
  					

![img](https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/03/06/kuangstudy263263ec-de4c-4fc7-bc7e-aeb339d5e073.png)

**完整的事务：**



![image-20210505114534333](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20210505114534333.png)

## **面试题：**

**为什么消息中间件不直接使用http协议呢？**

> 1: 因为http请求报文头和响应报文头是比较复杂的，包含了cookie，数据的加密解密，状态码，响应码等附加的功能，但是对于一个消息而言，我们并不需要这么复杂，也没有这个必要性，它其实就是负责数据传递，存储，分发就行，一定要追求的是高性能。尽量简洁，快速。
> 2:大部分情况下http大部分都是短链接，在实际的交互过程中，一个请求到响应很有可能会中断，中断以后就不会就行持久化，就会造成请求的丢失。这样就不利于消息中间件的业务场景，因为消息中间件可能是一个长期的获取消息的过程，出现问题和故障要对数据或消息就行持久化等，目的是为了保证消息和数据的高可靠和稳健的运行。

**Rabbitmq 为什么需要信道，为什么不是TCP直接通信**

> 1、TCP的创建和销毁，开销大，创建要三次握手，销毁要4次分手。
>
> 2、如果不用信道，那应用程序就会TCP连接到Rabbit服务器，高峰时每秒成千上万连接就会造成资源的巨大浪费，而且==底层操作系统每秒处理tcp连接数也是有限制的，==必定造成性能瓶颈。
>
> 3、信道的原理是一条线程一条信道，多条线程多条信道同用一条TCP连接，一条TCP连接可以容纳无限的信道，即使每秒成千上万的请求也不会成为性能瓶颈。

**queue队列到底在消费者创建还是生产者创建？**

> 1： 一般建议是在rabbitmq操作面板创建。这是一种稳妥的做法。
> 2：按照常理来说，确实应该消费者这边创建是最好，消息的消费是在这边。这样你承受一个后果，可能我生产在生产消息可能会丢失消息。
> 3：在生产者创建队列也是可以，这样稳妥的方法，消息是不会出现丢失。
> 4：如果你生产者和消费都创建的队列，谁先启动谁先创建，后面启动就覆盖前面的

**为什么选择RabbitMQ而不是其他消息队列？**

> 有一个很活跃的社区，遇到的很多问题都可以找到答案。
>
> 支持多种客户端语言，减少了语言使用的限制。
>
> 完善的图形化界面，可以通过直接在网页的管理页面直接操作mq。
>
> 支持插件

**RabbitMQ怎么保证消息的可靠性？**

![img](https://kuangstudy.oss-cn-beijing.aliyuncs.com/bbs/2021/03/06/kuangstudy263263ec-de4c-4fc7-bc7e-aeb339d5e073.png)

![image-20210505104419877](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20210505104419877.png)

**消息幂等性问题**

> 定时重发可能会造成消息幂等性问题？即消息重复发送，然后被重复消费了。
>
> 可以通过唯一主键（唯一的订单号+业务类型）+redis的分布式锁（setnx）：
>
> 在第一次保存的时候，由于redis中没有该key,那么就会把全局唯一ID 进行设置上，此时订		单就会保存成功，这个时候若出现前端重复点击按钮, 由于第一步已经setnx上了 就会阻止		后面的保存。
>
> 服务端根据唯一的id 判断是否需要保存DB；消费端啊通过把唯一id通过redis的setnx命令		来保证幂等性。

**发送消息的过程中出现异常**

> 可以给出适当的补偿机制：
>
> 1.设置冗余表status
>
> 2.设置重发次数
>
> 3.超过次数，放入死信队列
>
> 4.放入死信队列的过程出错，人工处理

**消息处理机制**

> 如果发送的消息根本没有对应的exchange或者queue，该消息就会不可达；
>
> 如何处理这种消息？
>
> 1.如果生产者设置了mandatory为true，那么就会调用生产端的ReturnListener来处理。
>
> 2.如果没有设置该值，默认为false，那么该条消息就会被删除。