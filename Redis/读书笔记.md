

## 第八章 对象	

Redis对象的回收机制：应用计数。（同时还使用引用计数来实现对象共享机制，多个数据库键共享一个对象）。Redis对象都带有访问时间记录，如果在使用了maxmemory功能的话， 空转时间最长的对象会被优先删除。

### 8.1 对象的类型和编码

Redis对象表示的是数据库中的键和值，每次创建一个键值对时就会创建两个对象，一个键对象，一个值对象。

对象的结构为：

```c
typedef struct redisObject{
	//类型
	unsigned type 4;	
	//编码
	unsigned encoding :4;
	//指向底层实现数据结构的指针
	void *ptr;
} robj;
```

**具体编码对应底层实现**：

![image-20210713220317125](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20210713220317125.png)

补充：其中的embstr是使用 embstr 编码的简单动态字符串实现的字符串对象；当一个对象是字符串对象并且其长度小于等于39字节时，就会采用这种方式编码。**embstr最主要的区别**：raw编码会通过两次内存分配方式来分别创建redisObject和sdshdr结构，但是embstr则通过一个内存分配来分配一块连续的空间来依次包含上面两个结构。同时也是一次内存释放。，最主要还是一块连续内存，能更好地利用**缓存**带来地优势。

编码转换：当字符串值的长度大于 39 字节或执行修改命令smbstr将转换为raw编码，所以embstr实际是一个只读的对象。

还有一些其他对象大致都差不多。

```；
列表对象保存的所有字符串元素的长度都小于 64 字节；列表对象保存的元素数量小于 512 个（list-maxziplist-value；list-max-ziplist-entries）压缩列表--链表

哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；键值对数量小于 512 个（hash-max-ziplist-value；hash-max-ziplist-entries）压缩列表--字典

集合对象保存的所有元素都是整数值；元素的数量不超过 512 个（set-max-intset-entries） 整数集合--字典

有序集合保存的元素数量小于 128 个；有序集合保存的所有元素数量的长度都小于 64 字节（zset-max-ziplist-entries；zset-max-ziplist-value）压缩列表--字典+跳表

补充：有序集合中使用的是字典+跳转的结构（dict+zsl）；
	跳表节点的score属性保存的是元素的分值，通过跳表可以实现堆有序集合的范围查找。
	字典的键保存的是元素的成员，而字典的值是元素的分数，通过这个字典就可以实现O（1）复杂度的查找。
	很明显：如果只使用字典或者只使用跳表性能就会不如前者，只用字典会使得范围查找需要O（nlogn）时间+O（N）空间的复杂度。只用跳表就会要O（logn）查询复杂度。
	这两个结构中的元素以及其分数值是共享的，同时使用两者不会出现重复成员或分值，也不会浪费内存（通过指针指向相同地址）；
```



### 8.2对象共享

https://www.zhihu.com/question/338226330

为什么 Redis 不共享包含字符串的对象？

当服务器考虑将一个共享对象设置为键的值对象时，程序需要先检查给定的共享对象和键想创建的目标对象是否完全相同，只有在共享对象和目标对象完全相同的情况下，程序才会将共享对象用作键的值对象，而一个共享对象保存的值越复杂，验证共享对象和目标对象是否相同所需的复杂度就会越高，消耗 CPU 时间也会越多。

- 如果共享对象是保存整数数值的字符串对象，验证的操作是O1
- 如果共享对象是保存字符串数值的字符串对象，验证的操作是ON
- 如果共享对象是保存多个值的对象或者包含对象的对象，验证的操作是ON^2

所以Redis考虑虽然可以节约内存，但是会损耗cpu的性能，最终只对包含整数值的字符串对象进行共享。

### 8.3对象的空转时长

就是当前时间减去对象上次访问的时间。需要注意的是：

```
OBJECT IDLETIME 命令可以打印出给定键的空转时长，这一空转时长就是通过将当前时间减去键的值对象的 lru 时间计算得出的，这个命令在访问键的值对象时，不会修改值对象的 lru 属性
如果服务器打开了 maxmemory 选项，并且服务器用于回收内存的算法为 volatile-lru 或者 allkeys-lru，那么当服务器占用的内存数超过了 maxmemory 选项所设置的上限值时，空转时间较高的那部分键会优先被服务器释放，从而回收内存
```





## 第九章 数据库

数据库结构：

```c
服务器的数据库
struct redisServer{
	//一个数组，保存着服务器中的所有数据
	redisDb *db;
	//服务器数据库的数量
	int dbnum;
}；
客户端的数据库
struct redisClient{
	//记录着客户局正在使用的数据库
	redisDb *db;
	//服务器数据库的数量
	int dbnum;
}redisClient;
数据库
typedef struct redisDb{
    //...
    //数据库键空间，保存着数据库所有的键值对
    dict *dict;
    //过期时间
    dict *expires；//可以看到过期时间也是个字典。
}
```



```
select 命令的实现原理：比如select 2；就是切换到2号数据库，通过将客户端的db指针指向服务器的db数组中的2号数据库的地址来完成切换。
select切换数据库需要注意的点：若操作者是其他语言的客户端，然后你多次切换了数据库，可能会让你忘记当前使用的数据库是哪一个，所以每次都先执行一个select显示地切换数据库。

读写键空间的维护：
	在读取一个键之后，服务器会根据这个键是否存在来更新服务器的键空间命中次数或miss次数，可以使用 info stats来查看。
	读取一个键之后，服务器会更新键的LRU，可以使用object来查看键的空转时间。
	如果服务器发现一个键已经过期，则会删除该键，再执行其他操作。
	如果有客户端使用watch了某个键，则之后再对该键的修改会将这个键标记为脏数据，让事务知道该键已经被修改过了，并且每次修改脏数据都会让脏键计数器+1；
	如果有从服务器，那么主服务器修改键之后会通知从服务器。
```

![数据库结构图](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20210714094748959.png)

​														图 9-1

### 9.1键的过期时间

```
redis> set key value 
redis> expire key 5
redis> get key //5秒之内
"value"
redis> get key
nil

可以通过expire|pexpire来设置过期时间，客户端可以使用expireat|pexpireat；带p的命令是以毫秒来设置
可以通过ttl|pttl来查看键的剩余过期时间。
```

从图9-1我们可以看到过期时间也是一个字典，和键值对相对应。如果一个键有过期时间，那么在expires字典中也会有对应的键值对，其中键对应的值是过期的时间。

**原理部分**

ttl和pttl都是通过计算键的过期时间和当前时间之间的差来实现的。具体的代码在书上，有点多，不想敲了。。。---pttl(key)

判断一个键是否过期，is_expired(key)

```
1.检查给定键是否存在过期字典中，如果存在，那么取得键的过期时间。
2.检查当前unix时间戳是否大于键的过期时间：如果是的话，那么键已经过期了；否则的话，键未过期;
```

### 9.2过期键的删除策略

这里有三种删除策略：*******！！！！

```
定时删除：根据过期时间，设置定时器，在过期的时候执行删除；
惰性删除：每次从键空间中过去键的时候就判断一下；
过期删除：每隔一段时间，对数据库检查一次。
```

```
定时删除：对内存来说是最友好的，因为一个键一旦过期就删除，不会浪费内存。同样缺点也很明显：对cpu占用很严重，在一个键删除之前他都一直占用cpu，这样无疑会对服务器的响应时间和吞吐量造成很大影响。同时，创建定时器需要用到redis的时间事件，其实现方式是无序链表，这个结构查找一个事件的事件是O（n），并不能很高效地处理事件。
惰性删除：对cpu最友好，但是如果一个键已经过期，同时也没有任何客户端去访问他的话，就会一直占用内存。大量键累积起来就会造成  ！内存泄露！；
定期删除：是前两种的折中方式，但是其难点是如何设置删除操作的时长和频率。
```

**综上：redis使用的定期删除和惰性删除两种结合的方式**

实现方式：

**惰性删除**：

![image-20210714105912706](C:\Users\86137\AppData\Roaming\Typora\typora-user-images\image-20210714105912706.png)

**定期删除**

调用的redis.c/activeExpireCycle函数。每当服务器周期性地操作redis.c/serverCron函数执行时，activeExpireCycle就会被调用。（代码不想弄了。）

```
activeExpireCycle：
1.函数执行时会随机从数据库中随机取出一定数量的键进行检查，并删除其中的过期键。
2.全局变量current_db会记录函数的调用进度，使得下一次调用会接着上次的进度。
3.随着函数一直调用，数据库迟早会被全检查一边，然后就会从头开始继续检查。current_db会被置为0；
```



### 9.3AOF、RDB和复制功能过期键的处理



```
1.在执行 SAVE 命令或者 BGSAVE 命令创建一个新的 RDB 文件时，程序会对数据库中的键进行检查，已过期的键不会被保存到新创建的 RDB 文件中
2.	rbd写入时
		如果服务器以主服务器模式运行，那么在载入 RDB 文件时，程序会对文件中保存的键进行检查，未过期的键会被载入到数据库中，而过期键则会被忽略，所以过期键对载入 RDB 文件的主服务器不会造成影响
		如果服务器以从服务器模式运行，那么在载入 RDB 文件时，文件中保存的所有键，不论是否过期，都会被载入到数据库中。不过，因为主从服务器再进行数据同步的时候，从服务器的数据库就会被清空，所以一般来讲，过期间对载入 RDB 文件的从服务器也不会造成影响
3.	aof写入时
		当服务器以 AOF 持久化模式运行时，如果数据库中的某个键已经过期，但它还没有被惰性删除或者定期删除，那么 AOF 文件不会因为这个过期键而产生任何影响
		当过期键被惰性删除或者定期删除之后，程序会向 AOF 文件追加一条 DEL 命令，来显示地记录该键已被删除
4.	aof重写
		和生成 RDB 文件时类似，在执行 AOF 重写的过程中，程序会对数据库中的键进行检查，已过期的键不会被保存到重写后的 AOF 文件中
5.	复制
		主服务器在删除一个过期键后，会显式地向所有从服务器发送一个 DEL 命令，告知从服务器删除这个过期键；从服务器在执行客户端发送的读命令时，即使碰到过期键也不会将过期键删除，而是继续像处理未过期的键一样来处理过期键；从服务器只有在接到主服务器发来的 DEL 命令之后，才会删除过期键
```



## 第十章 RDB持久化

Redis是内存数据库，一旦服务器进程退出，那么服务器中的数据就会消失不见，为了解决这个问题，Redis提供了RDB持久化的功能，可以将内存的数据保存在磁盘上。RDB持久化功能是压缩生成一个二进制文件，通过该文件可以还原到生成RDB文件时的数据库状态。